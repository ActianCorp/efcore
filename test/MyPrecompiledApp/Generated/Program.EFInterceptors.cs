// <auto-generated />

using MyPrecompiledApp;
using MyPrecompiledApp.Generated;
using System;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.ChangeTracking.Internal;
using Microsoft.EntityFrameworkCore.Diagnostics;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Infrastructure.Internal;
using Microsoft.EntityFrameworkCore.Internal;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Query;
using Microsoft.EntityFrameworkCore.Query.Internal;
using Microsoft.EntityFrameworkCore.Storage;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Data.Common;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Threading.Tasks;

#pragma warning disable EF9100 // Precompiled query is experimental

namespace Microsoft.EntityFrameworkCore.GeneratedInterceptors
{
    file static class EntityFrameworkCoreInterceptors
    {
        #region Query1

        [InterceptsLocation(@"D:\git\efcore\test\MyPrecompiledApp\Program.cs", 16, 41)]
        public static IQueryable<TEntity> Query1_AsNoTracking1<TEntity>(this IQueryable<TEntity> source)
        where TEntity : class
        {
            var precompiledQueryContext = new PrecompiledQueryContext<TEntity>(((IInfrastructure<DbContext>)source).Instance);
            return precompiledQueryContext;
        }

        [InterceptsLocation(@"D:\git\efcore\test\MyPrecompiledApp\Program.cs", 16, 56)]
        public static IQueryable<TSource> Query1_Where2<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, bool>> predicate)
        {
            var precompiledQueryContext = (PrecompiledQueryContext<TSource>)source;
            return precompiledQueryContext;
        }

        [InterceptsLocation(@"D:\git\efcore\test\MyPrecompiledApp\Program.cs", 16, 77)]
        public static List<TSource> Query1_ToList3<TSource>(this IEnumerable<TSource> source)
        {
            var precompiledQueryContext = (PrecompiledQueryContext<TSource>)source;
            var queryContext = precompiledQueryContext.QueryContext;
            Query1_Executor ??= Query1_GenerateExecutor(precompiledQueryContext.DbContext, precompiledQueryContext.QueryContext);
            var queryingEnumerable = ((Func<QueryContext, IEnumerable<TSource>>)Query1_Executor)(queryContext);
            return queryingEnumerable.ToList();
        }

        private static object Query1_GenerateExecutor(DbContext dbContext, QueryContext queryContext)
        {
            var relationalModel = dbContext.Model.GetRelationalModel();
            var relationalTypeMappingSource = dbContext.GetService<IRelationalTypeMappingSource>();
            var materializerLiftableConstantContext = new RelationalMaterializerLiftableConstantContext(
                dbContext.GetService<ShapedQueryCompilingExpressionVisitorDependencies>(),
                dbContext.GetService<RelationalShapedQueryCompilingExpressionVisitorDependencies>(),
                dbContext.GetService<RelationalCommandBuilderDependencies>());
            var relationalCommandTemplate = (IRelationalCommandTemplate)new RelationalCommand(materializerLiftableConstantContext.CommandBuilderDependencies, "SELECT [e].[Id], [e].[Name]\r\nFROM [Entities] AS [e]\r\nWHERE [e].[Id] > 5", new IRelationalParameter[] { });
            var emptyValueBuffer = ValueBuffer.Empty;
            var emptySnapshot = Snapshot.Empty;
            var myEntityEntityType = materializerLiftableConstantContext.Dependencies.Model.FindEntityType("MyPrecompiledApp.MyEntity");
            var myEntityEntityType0 = (RuntimeEntityType)myEntityEntityType;
            var myPrecompiledApp.MyEntityPrimaryKeyProperties = myEntityEntityType.FindPrimaryKey().Properties;
            return (QueryContext queryContext) => SingleQueryingEnumerable.Create((RelationalQueryContext)queryContext, (parameters) => relationalCommandTemplate, null, (QueryContext queryContext, DbDataReader dataReader, ResultContext resultContext, SingleQueryResultCoordinator resultCoordinator) =>
{
    var entityType1 = default(IEntityType);
    var materializationContext1 = new MaterializationContext(in emptyValueBuffer, queryContext.Context);
    var instance1 = default(MyEntity);
    if ((object)dataReader.GetInt32(0) != null)
    {
        var shadowSnapshot1 = emptySnapshot;
        entityType1 = myEntityEntityType;
        if (entityType1 == myEntityEntityType)
        {
            var instance = new MyEntity();
            MyEntityEntityType.UnsafeAccessor_MyPrecompiledApp_MyEntity_Id(instance) = dataReader.GetInt32(0);
            MyEntityEntityType.UnsafeAccessor_MyPrecompiledApp_MyEntity_Name(instance) = dataReader.GetString(1);
            if (instance is IInjectableService)
            {
                ((IInjectableService)instance).Injected(materializationContext1.Context, instance, QueryTrackingBehavior.NoTracking, myEntityEntityType0);
            }

            instance1 = instance;
        }
        else
        {
            instance1 = default;
        }
    }
    else
    {
        var keyValues1 = new object[]
        {
            dataReader.GetInt32(0)
        };
        ShapedQueryCompilingExpressionVisitor.CreateNullKeyValueInNoTrackingQuery(myEntityEntityType, myPrecompiledApp.MyEntityPrimaryKeyProperties, keyValues1);
    }

    var entity = instance1;
    return entity;
}, typeof(MyContext), false, false, true);
        }

        private static object Query1_Executor;

        #endregion Query1
    }
}

namespace System.Runtime.CompilerServices
{
    [AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]
    file sealed class InterceptsLocationAttribute : Attribute
    {
        public InterceptsLocationAttribute(string filePath, int line, int column) { }
    }
}
